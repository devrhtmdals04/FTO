## 1부: 스탯이 물리 매개변수로 변환되는 방법.
   * 스탯의 출처부터 시작: player_data.rs는 각 플레이어의 기본 속성(1-20 스케일)을 제공합니다.

   * 변환 함수 설명: packages/engine/src/state.rs의 compute_params_20이 핵심 함수입니다.

   * compute_params_20 내부 단계 설명:
       * 매핑: map_inc 헬퍼 함수를 사용하여 1-20 스탯(pace 등)을 물리 범위(v_max의 경우 5.6~7.6m/s 등)에 매핑합니다.
       * 생체 역학적 조정: 이러한 초기 물리 값은 현실감을 더하기 위해 플레이어의 키와 몸무게를 기준으로 조정됩니다.

   * 최종 출력 언급: 결과는 최종적인 플레이어별 물리 값(v_max, a_max 등)을 포함하는 PlayerParams 구조체입니다.

   * 사용처 설명: 이 PlayerParams 구조체는 packages/engine/src/physics/player.rs의 integrate_player 함수 내에서 매 프레임 플레이어의 움직임을 
     시뮬레이션하는 데 사용됩니다.

  2부: 변환을 조정하는 방법.
   * 매핑 조정: 1-20 스탯이 물리 값으로 변환되는 방식을 변경하려면 사용자는 state.rs의 compute_params_20 내 map_inc 호출의 인수를 수정해야 합니다.
      예를 들어, pace가 높은 플레이어를 더 빠르게 만들려면 map_inc(inp.pace, 5.6, 7.6, 1.0)에서 hi 값을 높일 수 있습니다.

   * 전역 물리 조정: 모든 플레이어에게 영향을 미치는 전역 변경의 경우 사용자는 packages/engine/src/params.rs의 상수를 수정해야 합니다. 이전에 
     여기서 PLAYER_VMAX와 PLAYER_AMAX를 수정했지만 compute_params_20의 현재 로직은 이를 직접 사용하지 않고 자체 하드코딩된 범위를 사용합니다. 이 
     점을 지적해야 합니다. params.rs의 상수는 더 단순한 속성 기반이 아닌 모델을 위한 것이거나 레거시 코드일 수 있습니다. 실제 제어는 
     compute_params_20에 있습니다. 이것은 중요한 설명입니다.

   * 재빌드 필요: engine 패키지에서 변경 사항이 발생하면 코드를 WebAssembly로 다시 컴파일해야 합니다. 사용자에게 이 방법을 알려줘야 합니다. 아직 
     명확한 빌드 스크립트를 찾지 못했습니다. 단서를 찾기 위해 packages/engine/Cargo.toml을 확인하겠습니다. 찾을 수 없으면 사용자에게 빌드 명령을 
     실행해야 한다고 말하고, 찾을 수 없으면 무엇인지 물어보겠습니다.

 
## 과정 요약 및 수치 조정 가이드입니다.

  요약: 선수 스탯이 물리 법칙으로 전환되는 과정

  선수의 능력치(1-20 스케일)가 실제 게임 내 물리 움직임으로 변환되는 과정은 다음과 같습니다.

   1. 능력치 정의 (`player_data.rs`):
       * 각 선수의 pace, accel 등과 같은 기본 능력치는 player_data.rs 파일에 정의되어 있습니다. 이것이 모든 계산의 시작점입니다.

   2. 물리 파라미터 계산 (`state.rs`의 `compute_params_20` 함수):
       * 이 함수가 핵심입니다. player_data.rs에서 가져온 1-20 능력치를 실제 물리 엔진에서 사용하는 파라미터(최대 속도, 가속도 등)로 변환합니다.

       * 매핑(Mapping): map_inc 와 같은 함수를 사용하여 pace 능력치를 실제 v_max (최대 속도, m/s) 값으로 변환합니다. 예를 들어, pace가 20인 선수는
          7.6 m/s, 1인 선수는 5.6 m/s의 속도를 갖게 됩니다.

       * 신체 조건 보정: 매핑된 값은 선수의 키와 몸무게에 따라 추가적으로 보정됩니다. 예를 들어, 키가 큰 선수는 속도가 약간 더 빨라지고, 무거운 
         선수는 가속이 약간 느려지는 식의 현실적인 조정이 들어갑니다.

   3. 물리 시뮬레이션 적용 (`physics/player.rs`의 `integrate_player` 함수):
       * compute_params_20에서 계산된 최종 PlayerParams(선수별 물리 파라미터)는 이 함수로 전달됩니다.

       * integrate_player 함수는 매 프레임마다 각 선수의 v_max, a_max 등의 파라미터를 참조하여 실제 움직임(가속, 감속, 회전)을 시뮬레이션합니다.

  ---

## 수치 조정 방법

  게임의 물리나 선수들의 움직임을 조정하고 싶으시다면, 다음 두 가지 방법을 사용할 수 있습니다.

   1. 개별 능력치가 물리 값에 미치는 영향 조정 (더 정교한 제어):
       * 파일: packages/engine/src/state.rs

       * 방법: compute_params_20 함수 내의 map_inc(...) 또는 map_dec(...) 함수의 인자를 수정합니다.

       * 예시: 선수들의 전반적인 pace를 더 빠르게 만들고 싶다면, v_max를 계산하는 아래 코드에서 두 번째(최소값)와 세 번째(최대값) 인자를 높이면 
         됩니다.

   1         // 현재 코드
   2         let mut v_max = map_inc(inp.pace, 5.6, 7.6, 1.0);
   3 
   4         // 예시: 최대 속도를 8.0 m/s 로 상향 조정
   5         let mut v_max = map_inc(inp.pace, 5.6, 8.0, 1.0);
       * 키/몸무게 보정 로직을 수정하여 신체 조건의 영향을 다르게 줄 수도 있습니다.

   2. 전역 물리 상수 조정 (간단한 전체 변경):
       * 파일: packages/engine/src/params.rs

       * 방법: 이 파일에 있는 MU_GROUND (지면 마찰력), G (중력) 등의 상수를 직접 수정합니다. 이 값들은 모든 선수와 공에 전역적으로 영향을 
         미칩니다.

       * 참고: 현재 로직에서는 PLAYER_VMAX와 PLAYER_AMAX 상수는 compute_params_20 함수에서 재계산되므로 직접적인 영향을 주지 않을 수 있습니다. 
         선수 속도/가속도 조정은 방법 1을 사용하는 것이 더 확실합니다.

  ---

  ## 중요: 변경 사항 적용 방법

  engine 패키지 내의 Rust 코드(.rs 파일)를 수정한 후에는, 변경 사항을 웹 애플리케이션에 적용하기 위해 WebAssembly 모듈을 다시 빌드해야 합니다.

  ## pkg/engine 디렉토리에서 wasm-pack build --target web 입력.

  프로젝트의 빌드 스크립트를 찾아보았으나 명시적인 명령어를 찾지 못했습니다. 보통 어떻게 엔진을 빌드하시나요? 알려주시면 제가 직접 실행해 드릴 
  수 있습니다. 예를 들어, npm run build:engine 과 같은 명령어가 있을 수 있습니다.


  ## map_inc(s, lo, hi, g) 함수 설명 (증가 매핑)

  이 함수는 능력치가 높을수록 더 좋은(높은) 물리 값을 갖도록 매핑할 때 사용됩니다. 예를 들어, pace가 높을수록 v_max(최대 속도)가 높아지는 
  경우입니다.

  함수의 작동 원리를 단계별로 살펴보겠습니다.

   1 fn map_inc(s: u8, lo: f32, hi: f32, g: f32) -> f32 {
   2     // 1. 능력치 정규화 (0.0 ~ 1.0)
   3     let u = (s as f32).clamp(0.0, 20.0) / 20.0;
   4     // 2. 선형 보간(Lerp) 및 감마 보정
   5     lo + (hi - lo) * u.powf(g)
   6 }

   1. 능력치 정규화 (`u` 계산)
       * s는 선수의 능력치 점수(1-20)입니다.
       * 이 점수를 20으로 나누어 0.0에서 1.0 사이의 값으로 정규화합니다.
       * 예: pace가 10이면 u는 0.5가 되고, 20이면 1.0이 됩니다. 이 u 값은 전체 범위(lo ~ hi)에서 어느 지점에 위치할지를 결정하는 비율이 됩니다.

   2. 선형 보간 및 감마 보정 (`lo + (hi - lo) * u.powf(g)`)
       * lo는 최소값, hi는 최대값을 의미합니다. (hi - lo)는 변환될 값의 전체 범위입니다.
       * u.powf(g)는 정규화된 값 u에 g(감마) 값만큼 거듭제곱을 적용하여 곡선의 형태를 조절합니다.
           * `g = 1.0` (선형): 능력치가 오르는 만큼 물리 값도 정직하게 직선적으로 증가합니다. pace가 10(중간)이면 속도도 정확히 중간값이 됩니다.
           * `g > 1.0` (느린 초반, 빠른 후반): 능력치가 낮을 때는 물리 값의 성장이 더디다가, 최상위권 능력치에 가까워질수록 급격하게 증가합니다. 
             즉, 월드클래스 선수와 좋은 선수 간의 격차를 더 크게 만듭니다.
           * `g < 1.0` (빠른 초반, 느린 후반): 낮은 능력치에서도 물리 값이 빠르게 성장하고, 상위권으로 갈수록 성장폭이 둔화됩니다. 평범한 선수들도
              꽤 좋은 물리 값을 갖게 됩니다.
       * 최종적으로 최소값 + 범위 * 비율 형태의 선형 보간(Lerp) 공식을 통해 lo와 hi 사이의 특정 값을 계산해냅니다.

  예시: v_max = map_inc(pace, 5.6, 7.6, 1.0)
   * pace가 10이고 g가 1.0이라면, u는 0.5가 됩니다.
   * 계산: 5.6 + (7.6 - 5.6) * 0.5 = 5.6 + 2.0 * 0.5 = 6.6
   * 즉, pace가 10인 선수의 최대 속도는 6.6 m/s가 됩니다.

  ---

  ## map_dec(s, lo, hi, g) 함수 설명 (감소 매핑)

  이 함수는 능력치가 높을수록 더 좋은(낮은) 값을 갖도록 매핑할 때 사용됩니다. 예를 들어, passing 능력치가 높을수록 pass_err_sigma(패스 에러율)가
   낮아지는 경우입니다.

   1 fn map_dec(s: u8, lo: f32, hi: f32, g: f32) -> f32 {
   2     let u = (s as f32).clamp(0.0, 20.0) / 20.0;
   3     // `map_inc`와 달리 `hi`에서 값을 뺍니다.
   4     hi - (hi - lo) * u.powf(g)
   5 }

   * map_inc와 거의 동일하지만, 최종 계산에서 lo에 더하는 대신 hi에서 값을 뺍니다.
   * 따라서 능력치(s)가 20에 가까워져 u가 1.0이 되면, 결과는 hi - (hi - lo) 즉, lo(최소 에러율)가 됩니다.
   * 반대로 능력치가 1에 가까워 u가 0.0에 가까워지면, 결과는 hi(최대 에러율)에 가까워집니다.

  이 두 함수를 통해 선수의 1-20 능력치를 게임 플레이에 직접적인 영향을 미치는 다양한 물리 및 스킬 파라미터로 유연하게 변환할 수 있습니다.